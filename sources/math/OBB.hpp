#pragma once

#include "math_types.hpp"
#include "Vector3.hpp"
#include "Matrix4x4.hpp"

namespace brUGE
{
namespace math
{
	
	//-- OBB stands for Oriented Bounding Box.
	//----------------------------------------------------------------------------------------------
	class OBB
	{
	public:
		inline OBB() { m_transform.setIdentity(); }
		inline explicit OBB(const mat4f& tranform) : m_transform(tranform) { }
		inline ~OBB() {}

		//-- copy constructor and assign operator will be generated by compiler.
		
		inline const mat4f& transform() const { return m_transform; }
		inline void transform(const mat4f& mat);
		inline bool intersect(const vec3f& start, const vec3f& dir, float& dist, vec3f& coll) const;

	private:
		mat4f m_transform; //-- 64 bytes. Try to minimize total memory amount.
	};
	
	inline void OBB::transform(const mat4f& mat)
	{
		m_transform.postMultiply(mat);
	}
	
	//-- Note: dir vector is not normalized, its length is max distance of collision test.
	//----------------------------------------------------------------------------------------------
	inline bool OBB::intersect(const vec3f& start, const vec3f& dir, float& dist, vec3f& coll) const
	{
		//-- 1. find invert transform of OBB.
		mat4f inv = m_transform.getInverted();
		
		//-- 2. convert start and dir vectors into local to OBB space.
		vec3f lstart = inv.applyToPoint(start);
		vec3f ldir   = inv.applyToVector(dir);
		
		//-- 3. do collision test in local to OBB space against identity AABB.
		float tfirst = 0.0f, tlast = 1.0f;

		if (!raySlabIntersect(lstart.x, ldir.x, -1.0f, 1.0f, tfirst, tlast)) return false;
		if (!raySlabIntersect(lstart.y, ldir.y, -1.0f, 1.0f, tfirst, tlast)) return false;
		if (!raySlabIntersect(lstart.z, ldir.z, -1.0f, 1.0f, tfirst, tlast)) return false;
		
		//-- 4. setup result.
		coll = start + dir.scale(tfirst);
		dist = tfirst * dir.length();

		return true;
	}

} //-- math
} //-- brUGE